\Chapter{Megvalósítás}

Ebben a fejezetben kerül részletes bemutatásra a program implementációjának folyamata, kiegészítve a nehézségekkel, problémákkal és azok megoldásával. 

Mivel a csomagadatok lekérdezése egyszerűen megoldható az npm Registrynek köszönhetően, így gond nélkül lehet rekurzív keresést implementálni, amelynek eredményeként megkaphatjuk egy adott csomag adott verziójának összes függőségét.

\section{Csomag Szerkezet}
Az npm csomagok szerkezetére vannak megkötések, így a projekt szerkezetét is ilyen formára kell hozni. Elkészült hozzá a \texttt{package.json} fájl, amely tartalmaz minden kötelező és releváns opcionális mezőt. A csomag a \textbf{package-examiner} fantázianevet kapta.   

A csomag belépési pontja, a \texttt{package.json}-ban is jelzett \texttt{main.js}. A csomag funkcionális szerkezete az alábbi módon néz ki:

\begin{cpp}
./	
	src/
		- scripts
		- styles
		- templates
		- app.js
		- main.js
	public/
		- index.html
	package.json
	package-lock.json
	README.md	
\end{cpp}

Mint látható csak az \texttt{index} HTML fájl létezik, ennek oka a következő szakaszban részletezésre kerül.

\pagebreak

\section{Single-Page UI}

A Single Page Application, azaz SPA lényege, hogy egy oldalra dinamikusan tölti be a tartalmat, nem történik új lap nyitása, se újratöltés.

Ennek a megvalósítására több technológia létezik, többek között a jQuery könyvtár is. A program úgynevezett "JavaScript Template"-ekkel való megoldást alkalmazza, amely során JavaScript fájlokban hoz létre HTML sablonokat és azokat exportálja, majd az applikáció felhasználási módtól függően dinamikusan tölti be azokat.\\

\textbf{Egy ilyen exportálható JavaScript Template szintaktikája:}

\begin{cpp}
	const Template = () => {
		const template = `
		#Some HTML code
		`;
		return template;
	};

	export default Template;
\end{cpp}

A program az alábbi sablonokat tartalmazza:
\begin{cpp}
./templates/	
	Sidebar
	- Examiner.js
	- Statistics.js
	Canvas.js
	Sidebar.js
\end{cpp}

A Sidebar és Canvas sablonokat az app.js fájl tölti be automatikusan az index.html-be, ezek konstansan részét képezik az index tartalmának. A Sidebar és a Canvas tartalmának egy része azonban felhasználási módtól függően változik.

Az Examiner-t egy csomag, a Statistics-t több csomag vizsgálata estén tölti be. A két funkcionalitási mód közötti váltást egy "Switch Mode" gomb teszi lehetővé.\\

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.2]{images/ui_modes.png}
	\caption{Single / Multi Package Sidebar}
	\label{fig:ui_modes}
\end{figure}

\pagebreak


Az \textbf{Single Package Analysis} esetén, ha létező csomagra keresünk rá, akkor automatikusan felölti a Package Version listát. Mivel a Registry-ben szükséges verziók szerint keresni, ez biztosítja a keresés sikerességét.\\

Amennyiben a Registry-ben csak a csomagnévre keresünk rá, akkor nem fogunk függőségeket visszakapni, mivel itt általános információk vannak a csomagról, nem pedig működési információk. Konkrét információt a verzió megadásával tudunk megszerezni.\\

A Sidebar továbbá tartalmaz egy konstansan jelen lévő kapcsolót, amellyel a világos és sötét megjelenítési mód között lehet választani, az alapértelmezett mód a sötét, viszont \underline{nyomtatási szempontból} a \textbf{világos módot} fogom használni az ábrákhoz. 

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.15]{images/ui_darkmode.png}
	\caption{UI Sötét/Világos mód}
	\label{fig:ui_darkmode}
\end{figure}

A csomagok adatainak lekérdezését, függőségek összegyűjtését, elemzését és ábrázolását végző funkciókat a következő "lekezelő" funkció indítja el, amint a szükséges információk ki vannak gyűjtve:

\begin{cpp}
window.handleFormEvents = (event) => {
	event.preventDefault();
	submitForm(event.target.id);
};
\end{cpp}

\pagebreak

\section{Adatgyűjtés}

Az adatok lekérésére két különböző modul áll rendelkezésre, a \textbf{getPackage.js} és a \textbf{searchPackages.js}

A program HTML formok küldés eseményére reagál, majd ezeket lekezeli és a form típusától függően hív meg függvényeket. Ezt a \textbf{handleSideBarEvents.js} modul fogja végezni, mely az alábbiak szerint dönti el, hogy mely funkciókat hívja meg:

\begin{cpp}
function submitForm(form){
	switch (form) {
		case "packageForm":
		getPackageData();
		break;
		case "graphingForm":
		makeGraph();
		break;
		case "statForm":
		makeStat();
		break;
		default:
		break;
	}
}
\end{cpp}

\noindent\textbf{getPackageData()}
\begin{itemize}
	\item Ez a funkció felelős a "Package Version" Select DOM elem listájának feltöltéséért. 
	\item Amennyiben nem található a csomag, hibát fog dobni
	\item Közvetlenül támaszkodik a \textbf{getPackage.js} modulra
\end{itemize}

\noindent\textbf{makeGraph()}
\begin{itemize}
	\item Ez a funkció felelős a kiválasztott csomag függőségei gráfjának megalkotásáért, megrajzolásáért, majd pedig elemzéséért
	\item Amennyiben nincs kiválasztva a verzió, hibát fog dobni.
	\item Közvetetten támaszkodik a \textbf{getPackage.js} modulra
\end{itemize}

\noindent\textbf{getPackageData()}
\begin{itemize}
	\item Ez a funkció felelős több csomagos mód esetén a megadott paraméterek szerinti csomagok összegyűjtéséért, függőségi elemzéséért és statisztikai ábrázolásáért.
	\item Amennyiben nem található a csomag, hibát fog dobni
	\item Közvetletetten támaszkodik a \textbf{searchPackages.js} modulra
\end{itemize}

\pagebreak

\subsection{Lekérdezések}

\textbf{Probléma:} Az npm Registry lekérdezésénél lehetőség van egy csomag adatainak lekérésére, illetve arra is, hogy a Registry-ben található csomagok között keressünk. Ezzel csak az a probléma, hogy a keresés a keresés szövege köré épül, tehát lényegében nem tudunk minden csomag esetében, megadott paraméterek szerint keresni, mivel legalább egy betűt elvár a keresési végpont.

\textbf{Megoldás:} A Libraries.io API-ja, amely lehetőséget ad arra, hogy popularitás, illetve egyéb szempontok szerint keressünk tetszőleges mennyiségű csomagot. Ez a több csomagos módnál szükséges lesz.

Az applikáció minden lekérdezése aszinkron, hogy ne befolyásolja a végfelhasználói élményt, így ameddig nincsenek adatok, törekedve arra, hogy a felhasználó tisztában legyen azzal, hogy a háttérben futnak a folyamatok, a képernyőn megjelenik egy körkörös, töltést jelző ikon.\\

\noindent 1) \underline{getPackage()}\\

\begin{cpp}
function getPackage(packageName, packageVersion="", requiredData=""){
	*do stuff*
	return pkg;
}
\end{cpp}

Ez a funkció egy csomagnevet vár el, illetve opcionálisan megadható a csomagverzió és arra is van lehetőség, hogy megadjuk, hogy a válaszként kapott objektumból milyen adatra van szükségünk.

A visszatérési érték a megadott paramétereknek megfelelő objektum lesz.

\noindent 2) \underline{searchPackages()}\\

\begin{cpp}
function searchPackages(size, sortBy){
	*do stuff*
	return pkgs;
}
\end{cpp}

Ez a funkció a lekérdezendő csomagok számát várja el, illetve, hogy mi alapján állítsa sorrendbe és adja vissza a tárolt adatokat.

A visszatérési érték a megadott paramétereknek megfelelő csomagokat tartalmazó objektum lesz.

\pagebreak

\subsection{HTTP Kérés}

A programon belül a HTTP kérések a fetch API segítségével valósulnak meg, amely a következő módon működik:

\begin{cpp}
async function fetchData(url){
	let response = await fetch(url);
	
	if (!response.ok) {
		throw new Error(response.status);
	}
	
	return response.json();
}
\end{cpp}

\textbf{async/await} módon működik, ígéretet ad arra, hogy fog adni adatot a meghívója számára, amely addig vár a futásával, de közben más feladatok futását nem akadályozza.

\textbf{URL:} Az URL attól függően, hogy egy csomag információira vagyunk kíváncsiak, vagy csomagokra bizonyos paraméterek szerint, a következő lehet:
\begin{itemize}
	\item Egy csomag esete: npm Registry (https://registry.npmjs.cf/)
	\item Több csomag esete: Libraries.io (https://libraries.io/api/search)
\end{itemize} 

\section{Gráfalkotás és Elemzés}

A \textbf{makeGraph()} funkció meghívásával kezdődik el a folyamat. A függvény amennyiben ki van választva egy csomag és annak egy verziója, meghívja a \textbf {grahpDependencies.js} modult. 

\begin{cpp}
function graphDependencies(pckg, dDepth, singleMode=true){
	
	let dependencies = await getDependenciesTillDepth(pckg, dDepth);
	let packages = dependencies[dependencies.length-1];
	dependencies.pop(dependencies[dependencies.length-1]);
	
	let graphEntities = 
		calculateGraphData(packages, dependencies, singleMode);
	let currentGraph = 
		new Graph(graphEntities[0], graphEntities[1]);
	
	if(singleMode){
		analyseGraph(currentGraph);
	}
	
	return currentGraph;
}	
\end{cpp}

Egy és több csomagos módban is a makeGraph() a kiindulópont, mivel ez a funkció felelős egy adott csomag függőségeinek összegyűjtéséért, azok gráf struktúrába rendezéséért.
Visszatérési értékként a csomag függőségi gráf struktúráját adja vissza.\\

A \textbf{singleMode} boolean jellegű változó 'igaz' (alapértelmezett) érték esetén a következő extra funkciók is végrehajtásra kerülnek:
	\begin{itemize}
		\item A gráf struktúra kirajzolása
		\item A gráf analizálása
	\end{itemize}

Következő lépésként fog megtörténni az adott csomag függőségeinek rekurzív keresése. Ezt a \textbf{getDependencies.js} modul fogja teljesíteni, amely az alábbi 3 függvényt tartalmazza:

\begin{cpp}
function getDependenciesTillDepth(pckg, depth){
	*do stuff*
	return dependencies;
}

function populateDependencies(pckg, depth){
	*do stuff*
	return dependencies;
}

function getDependencies(pckg){
	*do stuff*
	return returnDeps;
}
\end{cpp}

\subsection{A getDependencies modul}

Először a \textbf{getDependenciesTillDepth()} függvény kerül meghívásra, ez attól függően, hogy megadták-e hogy milyen mélyen keressen fogja megkeresni az adott csomag függőségeit, majd ezeket egy tömbként fogja visszaadni. A tömb utolsó elemét mindig a csomagok tömbje képzi, amelyektől függ a kiinduló csomag.\\

\textbf{Mélység: }A keresés mélysége az a szám, amelyre még kiterjed a keresés. Ez nem a függőségi gráf szintje. Egy szint megfelel az adott csomag közvetlen függőségeinek. Tehát az első szint mindig a gyökérelem direkt függőségei, a második szint a direkt függőségek közvetlen függőségei, és így tovább.\\

A \textbf{getDependenciesTillDepth()} függvény rekurzívan fogja megkeresni a függőségeket, minden szint esetében. Az aktuális mélységi szinten minden csomag esetében meghívásra kerül a \textbf{populateDependencies()} függvény a csomaggal paraméterként, és a keresés aktuális mélységi szintjével.

\pagebreak

A \textbf{populateDependencies()} a csomag összes függőségét lekérdezi, a \textbf{getDependencies()} függvény segítségével, majd a visszakapott függőségeken végighaladva egy olyan tömböt fog visszaadni, amely minden függőségről az alábbi adatokat fogja tartalmazni:
\begin{itemize}
	\item Csomag Neve
	\item Verzió
	\item Mélységi Szint
	\item Szülő
	\item Szülő Verziója
\end{itemize}

A \textbf{getDependencies()} függvény a getPackage() requiredDate paramétereként függőséget megadva csak a függőségeket kéri le az adott csomagról és adja vissza a populateDependencies()-nek.

Amennyiben a keresés szintje megadásra kerül, akkor addig a szintig gyűjti össze az összes ilyen objektumot, ha nem kerül megadásra, akkor addig keres, amíg meg nem találja az összes függőséget, majd visszaadja az objektumokat tartalmazó tömböt.\\

\subsection{Szemantikus verziózás problémája:}

A kezdeti futtatások, tesztek során kiderült, hogy nem minden esetben egy konkrét csomag verziót van megjelölve a függőségeknél. 

Természetesen ennek hatására a program hibás HTTP kéréseket intézett a Registry felé, amely 404 vagy 405-ös hibakódokkal reagált a kérésekre, mivel vagy nem létezett a csomag, vagy a megadott csomag nem létezett. 

A 404-es hibákat alapvetően azért kapta, mert ha "scoped" csomagot vizsgált akkor a "@scope/packagename" formát nem tudta az URL fogadni, itt egy a '/' jel '\%2'-re lecserélése megoldotta a problémát.\\

A verziók problémája azonban ennél sokkal markánsabb volt. A hiba feltárását követően felkutattam a dokumentációt, amely a szemantikus verziózásról szólt. 

Kiderült, hogy az npm-nek van egy saját csomagja, amely ismeri és kezelni tudja szemantikus verziózás szintaktikáját, mely csomag neve \textbf{semver}. 

Használata a dokumentáció elolvasását követően nem tűnik összetettnek, a \textbf{getPackage} modulban kerül implementálásra a helyes verzió kiválasztása a lekérdezéshez, a \textbf{findMaxSatisfying()} függvény segítségével.

\pagebreak

\begin{cpp}
function findMaxSatisfying(packageName, range){
	let pkg = await fetchData(registryUrl+packageName);
	let versions = [];
	
	for(let version in pkg.versions){
		versions.push(version);
	}
	
	let max = semver.maxSatisfying(versions, range);
	return max;
}
\end{cpp}

A funkció az aktuális csomagot és az elfogadott verziók intervallumát kéri be. Ezek után lekéri az adott csomag minden verzióját. Ezt követően a \textbf{semver} maxSatisfying() függvényének megadva a verziókat tartalmazó tömböt és a szemantikus módon megadott elfogadott verziók intervallumát, visszaadja a legfrissebb verziót. amit még elfogad az intervallum.\\

\subsection{Adatok gráf struktúrába rendezése:}

Újra a graphDependencies() függvényben van a program, megszerezte a szükséges adatokat a gráf struktúrába rendezéshez.

Ekkor hívja meg a \textbf{calculateGraphData()} függvényt amely a csomagokat, a függőségeket kéri paraméterként, illetve azt, hogy kirajzolja-e a gráfot vagy sem. Ez egycsomagos mód esetén 'igaz' lesz.

A gráf rajzolásához és szerkezetének meghatározásához a \textbf{sigma.js} nevű gráfkészítő csomagot használja a program. A sigma objektum a gráf megrajzolásához két adathalmazt használ, az egyik a Node-ok azaz csomópontok, a másik az Edge-k, azaz gráfélek.\\

\textbf{Egy sigma példányosítás:
}
\begin{cpp}
var s = new sigma({ 
	container: 'container',
	renderer: {
		container: document.getElementById('container'),
		type: sigma.renderers.canvas,
	},
	settings: {
	}
}); 
\end{cpp}

A sigma.js canvason rajzolja meg a gráfot, beállításként meg lehet adni a csomópontok és élek attribútumait, élek típusát és egyéb opcionális attribútumokat.

\pagebreak

\textbf{Csomópontok és gráfélek megadása, a csomagokkal és függőségekkel:}

\begin{cpp}
for (let i = 0; i < packages.length; i++) { 
	s.graph.addNode({
		id: packages[i].Name,
		label: packages[i].Name,
		y: 0,
		x: 0+packages[i].Level,
		size: 1
	})        
}// Create graph nodes from packages
for (let i = 0; i < dependencies.length; i++) {
	s.graph.addEdge({
		id: 'edge_'+i,
		source: dependencies[i].Parent,
		target: dependencies[i].Name
	});
} // Create graph edges from dependencies
\end{cpp}

Az így feltöltött függőségi gráf azonban még közel sem reprezentatív. A cél ennek a gráfnak egy olyan felépítést adni, amely DAG jellegű. A DAG egy "Directed acyclic graph", azaz irányított körmentes gráfot jelent. Elméletileg minden függőségi gráf meg kell, hogy feleljen ennek, ha nem, akkor hiba van a függőségek megadásánál. Jelenlegi állapotban valahogy így nézne ki a gráf:\\

\textbf{A Vue.JS keretrendszer példája:}

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.4]{images/graph_wrong.png}
	\caption{Rossz gráf elrendezés}
	\label{fig:graph_wrong}
\end{figure}

\pagebreak

\subsection{Gráfrendező Algoritmus}
Mint látható a \ref{fig:graph_wrong} ábrán, a gráf nem valósítja meg a DAG elrendezést. A gráf helyes elrendezését megvalósító már létező algoritmust nem találtam, a legtöbb esetben az \textbf{npmgraph.an} példájához hasonlóan randomizáltan inkább hálós gráfot hoznak létre. \\

Ennek megfelelően saját algoritmust írtam a gráf csomópontjainak helyes elrendezésére. Az algoritmus két szakaszból épül fel, az 1. szakaszban (X koordináta) a horizontális rendezés történik a különböző szintekre, majd a 2. szakaszban (Y koordináta) az adott szinteken történik egy vertikális rendezés. 

\subsubsection{Gráfrendező Algoritmus: 1. Szakasz}

\begin{algorithm}
	\caption{Node X Coordinates}
	\centering
	\begin{algorithmic}
		\Require $nodes$ and $edges$		
		\State $changes \gets true$
		\While{ $changes$ }
			\State $changes \gets false$
			\ForAll{$edges$}
				\State Initialize $source$ and $target$
				\ForAll{$nodes$}
					\If{$edge.source = node$}
						\State $source \gets node$
					\ElsIf{$edge.target = node$}
						\State $target \gets node$
					\EndIf
					\If{$source$ is defined \textbf{and} $target$ is defined}
						\If{$source.x = target.x$}
							\State $target.x \gets target.x+1$
							\State $changes \gets true$
						\ElsIf{$source.x > target.x$}
							\State $target.x \gets source.x+1$
							\State $changes \gets true$
						\EndIf
						\State Break 
					\EndIf
				\EndFor
			\EndFor
		\EndWhile 
	\end{algorithmic}
\end{algorithm}

\pagebreak

\subsubsection{Gráfrendező Algoritmus: 2. Szakasz}

\begin{algorithm}
	\caption{Node Y Coordinates}
	\begin{algorithmic}	
		\Require $nodes$
		\State Initialize $nArray$
		\For{$i \gets 0$ \textbf{to} $nodes.length$}
			\If{$i < nodes.length$ \textbf{and} $nodes[i].x = nodes[i+1].x$}
				\State $nArray \gets nArray + nodes[i]$
			\ElsIf{$nArray.length > 0$}
				\State $nArray \gets nArray + nodes[i]$
				\State Initialize $offset$
				\If{$nArray[0]$ is even}
					\State $offset \gets 2/nArray.length$
				\Else
					\State $offset \gets 3/nArray.length$
				\EndIf
				\For{$j \gets 0$ \textbf{to} $nArray.length$}
					\If{$j = 0$}
						\State $nArray[j].y \gets Random(-0.5;\ 0.5)$
					\Else
						\If{$j$ is even}
						\State $nArray[j].y \gets nArray[j-2].y+offset$
						\Else
						\If{$j=1$}
						\State $nArray[j].y \gets nArray[j-1].y-offset$
						\Else
						\State $nArray[j].y \gets nArray[j-2].y-offset$
						\EndIf
						\EndIf
					\EndIf
				\EndFor
				\State $nArray.length \gets 0$
			\EndIf
		\EndFor
	\end{algorithmic}
\end{algorithm}

\pagebreak

\noindent\textbf{Az algoritmust lefutását követően Vue.JS \ref{fig:graph_wrong} ábrán látható felépítését az alábbi módon változtatta meg:}

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.4]{images/graph_right.png}
	\caption{Helyes gráf elrendezés}
	\label{fig:graph_right}
\end{figure}

\noindent\textbf{Egy nem várt meglepetés:}\\

A tesztelés során akadtak olyan csomagok, ahol a a gráf algoritmusa végtelen iterációban futott, ezzel lefagyasztva a programot.
Ennek az oka az volt, hogy egyes csomagok olyan verzójú csomagokat fogadtak el függőségnként, amelyekben függőségként a gyökércsomag volt megjelölve, vagy esetleg kört eredményeztek a függőségi gráfban, ritkán egy szülő<-->gyermek kölcsönönös függési viszony alakult ki két csomag között. Ezek problémásak lehetnek, mivel elvben egy függőségi gráfban ilyennek nem szabadna előfordulni.

Az ilyen problémák kiszűrésére az algoritmus kapott egy olyan kiegészítést, hogy a gyökércsomag koordinátáit semmiképpen ne lehessen változtatni, illetve ha két iteráció között sem sikerül érdemben javítani az elrendezésen, kilép az algoritmus, mert nem tud tovább rendezni.\\

\subsubsection{Visszatérés}

A calculateGraph() attól függően, hogy szükséges-e, megrajzolja a gráfot, és visszatér a helyes csomópontokkal és élekkel feltöltött tömbbel a \textbf{graphDependencies()} függvénybe, ahol az adatokból létre fog hozni egy gráf objektumot, a gráf osztály példányosításával:

\begin{cpp}
let currentGraph = new Graph(graphEntities[0], graphEntities[1]);
\end{cpp}

\pagebreak

\subsection{Gráf Osztály}

\begin{cpp}
class Graph{
	constructor(nodes, edges){
		this.name = nodes[0].id;
		this.nodes = nodes;
		this.edges = edges;
	}
	getMaxDepth(){
	}
	getLinksPerDepth(){
	}
	getNodeDegrees(){
	}	
}
\end{cpp}

Ez az osztály tartalmaz minden olyan adattagot és metódust, amelyre a függőségi gráf elemzésénél szükség lesz. Vissza fogja adni a fokszámot, a gráf mélységét, és azt is, hogy mélységi szintenként hány függőség van.

\subsection{Gráf Elemzése}

Egy csomagot vizsgáló mód esetén az utolsó előtti lépés a függőségi gráf elemzése, amelynek könnyítésére jött létre a gráf osztály, amellyel egyszerűen tudjuk elemezni a gráfot. Az elemzések eredményeit grafikus módon a \textbf{chart.js} diagram készítő csomaggal fogja majd ábrázolni a program.

\subsection{Javaslattétel}

\section{Függőségi Gráfok Statisztikai Vizsgálata}











